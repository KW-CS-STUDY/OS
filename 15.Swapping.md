# 페이지 교체
- 메모리-스토리지 시스템은 계층구조이다.
- 필요없는 데이터일수록 하위계층인 스토리지에 저장된다.

## 어떻게 하는가?
- 프로그래머가 필요에 의해서 할 때 : os의 도움이 필요없음
- process-level 교체 : 당장 안쓰는 프로세서의 페이지를 쫓아냄
- page-level 교체 : 당장 안쓰는 페이지 쫓아냄

## 어디에 하는가?
- 스토리지 시스템의 일부를 스왑공간으로 미리 확보
- 처음 포멧시 확보함
- 리눅스에서는 파티션으로, 윈도우에서는 하나의 파일로

#### Present bit
- page table에서 사용하는 플래그
- 이를 이용해서 지금 swap되어있는지 확인가능

## page fault 
- 페이지가 메모리에 없을때
- 운영체제는 이때 페이지를 다시 스왑인 해줘야한다. 
- 이때 동작하는 함수가 page-fault handler이다.
- 전체과정

![image](https://user-images.githubusercontent.com/30014736/197402885-d60cf74b-db31-4fac-87e1-33e74f45798c.png)

## 메모리가 가득차면?
- 메모리가 가득찼을때 스왑인 하기 위해서는 빈공간을 마련해야한다.
- 그때 교체정책이 사용됨
- swap daemon, page daemon으로 쫓아내고 불러옴
- 스왑이 불가능한 데이터도 있다. ex 커널, 변경없는 코드 등

## 교체정책들
- 어떠한 규칙으로 쫓아내야 최고의 성능?


### optimal
- 미래를 보고 가장 오랫동안 사용안되는거 쫓아냄
- 구현불가, 비교대상

### FIFO
- 선입선출 
- 성능은 별로
#### 벨라디의 anomaly 
- 보통은 캐시크기가 커지면 성능이 좋아지는데 FIFO에서는 특정 워크로드에서 성능이 오히려 나빠지는 경향도 있음

### Random
- 걍 랜덤
- 생각보다 성능 잘나옴


## 과거 참조

### LFU 
- 가장 적게 사용한놈 빼


### LRU
- 가장 오래 참조 안한놈 빼
- 스택 구조로 구현 -> 벨라디 어노말리 적용 x
- 모든곳에서 성능 좋은것은 아니다(루프같은 것에서는 별로). 하지만 대부분 좋음
- 구현이 힘듬 = 오버헤드가 큼

#### Approximating LRU
- 오버헤드를 줄이기 위해서 개념만 가져와서 간단하게 사용
- 시계 알고리즘 
- 돌아가는 포인터를 이용해서 가리킬때 0이면 교체, 1이면 0으로
- 포인터와 상관없이 참조하면 1로 바꿈

### 수정된 페이지일경우
- modified bit 플래그가 0이면 그냥 버리면 되는데 
- 1일경우 수정사항이 있다는 것이므로 디스크에 써야함

### Prefetching
- 공간적 로컬리티에 의해 필요할것같은 뒤의 연속된 페이지들 미리 가져오기

### Clustering, Grouping
- 묶어서 swap하자
- 오버헤드가 적다.

### Thrashing
- 실제 프레임의 수가 적어서 페이지 폴트가 너무 자주 일어날때
- 일은 안하고 계속 페이지 교체만한다.
- 필요한 모든 페이지가 교체되는 현상

### Working-set Model
- 쓰레싱을 분석하기 위해 워킹셋이라는 윈도우를 만들고
- 윈도우안에 로컬리티 측정하는 방법
