# 스케줄링
## 멀티프로세서 스케줄링
- 멀티 프로세서에서의 스케줄링은 싱글프로세서에서와는 다르다.
- 다양한 새로운 문제 발생, 다양한 생각해야할것들 

```
캐시 : 시간적, 공간적 locality를 사용하여 빠른 참조를 위해 메모리 내용을 기억하고 있는 공간
```

### Coherence
- 일관성 파괴
- 한 CPU에서 메모리 값 변경후 캐시에만 저장되어있는데
- 다른 CPU에서 해당 메모리 값을 사용할때 발생
- 변경내용이 메모리에 바로 저장되지 않고 캐시에 저장되기 때문에 발생

#### 해결법
- BUS snooping : 버스를 계속 관찰하여 업데이트 플래그가 서있으면 캐시 값 메모리에 쓴 후 사용

### Synchronization
- shared data 사용할땐 CPU들을 mutual exclusion(상호 배제)하게
- 한 CPU가 공유 데이터 사용할때 다른 CPU는 사용할 수 없게 해야함
- 임계구역으로 가려서 사용

### Cache Affinity
- 캐시의 효율성 향상을 위해서 가능하면 같은 job은 같은 cpu에서 실행 
- why? 캐시에 이미 연산중이던 값들이 저장되어있을 확률이 높음
- 스케줄링시 감안하고 해야함

## 구현법
### Single Queue Multiprocessor Scheduling(SQMS)
- 그냥 한 큐에 모든 프로세스 쭉 나열한 후
- 순서대로 CPU에 뿌림
- Cache affinity 해침, 만족하게 구현하려면 복잡성 증가

### Multi Queue Multiprocessor Scheduling(MQMS)
- 스케줄링 큐 여러개(CPU개수만큼)
- job이 들어오면 한 큐에서만 스케줄링(다른 큐로 이동하지 않음)
- 다른 CPU로 작업이 이동x -> cache affinity 좋음
- 하지만 하나의 큐가 비면 한놈은 놀고 한놈만 일하는 상황 발생
#### imbalance 발생
- 해결하기 위해서 job을 이동시켜야함 = Migration
- 구현법
1. 큐에서 가장 저조한 작업 선택
2. 이동할 타겟 큐 선택
3. 타겟 큐가 더 바쁘면 이동x, 아니면 이동
- 하지만 오버헤드가 많이 큼

### 리눅스에서는?
- Time slice로 작동
- TS가 0이 되면 cpu권한 넘겨주고, 다시 채워줌
- 140단계 우선순위
- O(1)스케줄러(상수시간에 결정)
- 0~99는 실시간 프로세스, 100~139는 일반 프로세스
- 각 우선순위마다 TS가 5ms씩 늘어남
#### 스케줄러
- 두개의 arr 사용
- active array에서 TS가 끝난애들을 expired array로 보내면서 TS채워줌
- active가 비었으면 두 array를 교체
#### 문제점
- 레벨 차이가 조금나도 절대적인값인 5ms씩 차이나기 때문에 초반엔 차이가 크고 후반엔 차이가 작다.
- 1레벨 차이를 꾸준히 1.25배로 상대적으로 증가


## 알고리즘 검증(평가)
### 결정적 모델
- 워크로드를 주어주고 동작 설명
- 동작설명에만 유용, 평가x
- 심플, 빠름

### 구현
- 완전한 방법
- 하지만 매우 어려움
- 실제구현해서 검증

### 시뮬레이션
- 모델화 시켜서 시뮬
- 랜덤으로 값을 만들어서 사용
- 여러 분포를 만들어서 사용하기도

### 수학적 방법
- 수학적으로 증명
- 하지만 제한된 환경에서만 가능
