# 운영체제 정리
## 스케줄링 알고리즘
### Multi-level Feedback Queue
- 이전의 알고리즘들은 run time을 알아야 적용가능
- 하지만 어떻게 이를 알 수 있을까?
- 그래서 큐가 여러개인 알고리즘 제안 
- 각 큐는 독립적인 알고리즘 사용가능
- 상위 큐에서 작업을 못끝내면 하위 큐로 내려가는 아이디어
- 실행은 상위 큐부터 실행

#### 특성에 기반
- cpu사용이 많은 프로세스가 있고, I/O요청이 많은 프로세스가 있다.
- 보통 I/O요청이 많은 프로세스는 높은 응답성요구
- 보통 CUP요청이 많은 프로세스는 높은 tt 요구
- I/O 요청이 많고 cpu사용이 적은 프로세스에게 우선권을 주자

### 문제점
- Starvation(기아) : 특정 프로세스가 cpu를 거의 못받을수도
- 스케줄링 알고리즘을 알고있으면 고의로 악용가능 : 99%cpu 쓰고 일부로 의미없는 I/O해서 가장 높은 우선순위 상시유지
- CPU요청이 많다가 I/O요청이 많아지는걸로 변화할수도 있음

### 해결방안
- 기아 해결방안: 주기적으로 가장 높은 우선순위로 올려주자
- 악용 해결방안
1. 그냥 한 레벨의 큐에서 사용하는 시간을 제한하자.
2. 낮은 우선순위면 긴 실행시간(리눅스에서는 반대로 높은 우선순위가 긴 실행시간 준다.)

### 그 외의 특징
낮은 우선순위면 


### 최종 Rules
- A, B 프로세스가 있을때
1. Priority(A) > Priority(B) 이면 A가 실행
2. Priority(A) = Priority(B) 이면 A,B가 RR로 실행
3. 처음에 큐에 들어오는 프로세스는 가장 우선순위 높은 큐로
4. 한 레벨의 큐에서 사용할수 있는 시간을 다쓰면 낮은큐로 내려간다.
5. 주기적으로 가장 높은 우선순위로 올려주자


## 멀티 프로세서 스케줄링
### 
