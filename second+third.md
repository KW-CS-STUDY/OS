# 프로세스

## CPU 가상화
- 우리가 사용하는 컴퓨터에는 다양한 프로그램들이 돌아간다. 
- 각각의 프로그램들은 CPU를 사용하여 목적을 달성하려고 한다. 
- 하지만 CPU는 하나 혹은 제한된 수만큼만 존재하기 때문에 나눠서 사용해야한다.
- 하지만 이런 상황을 신경쓰지않고 프로그램이 CPU를 독점한다고 가정하고 프로그램을 작성할 수 있게 하는 기술이 CPU 가상화이다.


``` CPU를 사용하려는 주체는 돌아가는 프로그램(=프로세스) ```

#### 프로세스의 구성요소
메모리
- 코드 : 실행가능한 프로그램 코드
- 데이터 : 전역변수, static변수가 저장되는 공간
- 스택 :  지역변수, 파라미터, 반환값등 저장하는 공간. 보통 높은주소부터 거꾸로 할당
- 힙 : 동적 할당에 사용하는 메모리 공간
레지스터
- 프로그램 카운터
- 스택 포인터

## 프로세스 생성
1. 프로그램 코드를 메모리에 올린다. 동시에 데이터 영역도 메모리에 올라온다.(한번에 올리는것이 아닌 필요할때 올리는 방식 사용)
2. 스택 영역을 할당한다.
3. 힙 영역을 할당한다.
4. 다양한 초기화 작업 수행
5. main함수 실행


## 프로세스의 상태
- running
프로세서에서 실행중인상태
- ready
CPU할당 대기중인상태
- blocked
I/O등 디스크 연산, 인터럽트 대기 등을 기다리는 상태

## 프로세스를 관리하는 구조
- PCB(Process control Block)을 사용하여 프로세스 관리
- 각 프로세스마다 한개 할당
- PCB가 가지는 대표적인 정보
```
CPU register : 현재 프로세스의 프로그램 카운터 값
PID : 현재 프로세스 식별ID
PPID : 부모 프로세스 아이디
중요도 : 스케줄링때 사용하는 중요성
프로세스 상태 : 앞에서 살펴본 3가지 상태
시그널 : 시그널핸들러 및 받은 시그널 신호들
CPU 스케줄링 정보 : 언제 실행되었는지, 중요도는 어떤지 등 스케줄링용 정보
MMAP : 메모리 맵
오픈 파일 정보
I/O상태
등등 매우 다양한 정보 사용
```
- 리눅스에서는 task_struct라는 자료구조를 사용

## Context Switch
- cpu 가상화는 여러번의 Context switch를 통해서 이루어진다. 
- 그래서 프로그래머는 레이스 컨디션등 특이한 상황을 제외하면 CPU를 전용한다고 생각하고 코드를 작성할 수 있다.
- 컨텍스트 전환은  크게 두가지 단계를 거침
1. 기존 프로세스의 정보들을 저장
2. 새 프로세스의 저장된 정보들을 불러오기
- 이러한 작업들은 생각보다 오버헤드가 큰 작업들 : 적정선을 찾아야함
- 컨텍스트 전환은 하드웨어, 특히 CPU 아키텍쳐에 큰 영향을 받음 : 레지스터세트가 서로 다르기 때문

## Limited Direct Execution
- 가장초기의 time sharing 기반 CPU 스케줄링 기법 
- OS가 프로세스이 실행에 전혀 관여없음
- 프로세스가 CPU를 한번 점유하면 끝날때까지 사용
- 문제점
1. 사용자 프로그램이 해선느 안되는 일을 할 수도 있음(보안영역 접근, I/O접근)등
2. CPU나 메모리자원을 혼자서 독점
- 해결법 : 권한을 2개로 나누자
1. 유저모드 : 일반적으로 하드웨어, 시스템기능에대한 제한적 접근
2. 커널모드 : 운영체제의 영역으로 모든 기능을 사용할 수 있음
- 시스템 콜을 이용하여 유저모드에서 커널모드로 하드웨어 시스템에 조심스럽게 접근 요청
### 시스템 콜
- 시스템콜은 유저영역에서 I/O등 하드웨어 자원을 사용하기 위해서 커널에 요청하는 함수이다. 
- trap이라는 과정으로 요청이 시작
- 유저영역에서 프로그램의 동작을 멈추고 커널 영역으로 들어가서 요청을 처리한다.
- trap table이라는 인터럽트 처리코드를 담은 테이블을 이용하여 처리를 하고 유저모드로 돌아간다.
- 정말 다양한 시스템 콜 존재

### 여러 프로세스가 있을때
- 여러 프로세스가 존재하면 어떻게 CPU점유를 관리할 것인가?
1. 협조(Cooperative) : 프로그램이 적당히 돌다가 알아서 wait를 건다.
2. 강탈(Non-Cooperative) : OS가 강제로 컨트롤을 뺏어온다.

### Cooperative 접근
- 프로세스가 cpu 자발적으로 포기 
- os는 다음 프로세스 결정만 하면된다.
- 물론 비정상적인 상황에서는 os가 cpu뺏어옴
- 최근엔 거의 사용하지 않음(악용가능)

### Non-Cooperative 접근
- 기본적으로 타이머 사용
- 타이머가 일정주기별로 강제 인터럽트 발생
- 인터럽트가 발생하면 OS가 cpu 뺐음
- 그후 다음 프로세스 선택
