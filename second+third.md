# 프로세스

## CPU 가상화
- 우리가 사용하는 컴퓨터에는 다양한 프로그램들이 돌아간다. 
- 각각의 프로그램들은 CPU를 사용하여 목적을 달성하려고 한다. 
- 하지만 CPU는 하나 혹은 제한된 수만큼만 존재하기 때문에 나눠서 사용해야한다.
- 하지만 이런 상황을 신경쓰지않고 프로그램이 CPU를 독점한다고 가정하고 프로그램을 작성할 수 있게 하는 기술이 CPU 가상화이다.


``` CPU를 사용하려는 주체는 돌아가는 프로그램(=프로세스) ```

#### 프로세스의 구성요소
메모리
- 코드 : 실행가능한 프로그램 코드
- 데이터 : 전역변수, static변수가 저장되는 공간
- 스택 :  지역변수, 파라미터, 반환값등 저장하는 공간. 보통 높은주소부터 거꾸로 할당
- 힙 : 동적 할당에 사용하는 메모리 공간
레지스터
- 프로그램 카운터
- 스택 포인터

## 프로세스 생성
1. 프로그램 코드를 메모리에 올린다. 동시에 데이터 영역도 메모리에 올라온다.(한번에 올리는것이 아닌 필요할때 올리는 방식 사용)
2. 스택 영역을 할당한다.
3. 힙 영역을 할당한다.
4. 다양한 초기화 작업 수행
5. main함수 실행


## 프로세스의 상태
- running
프로세서에서 실행중인상태
- ready
CPU할당 대기중인상태
- blocked
I/O등 디스크 연산, 인터럽트 대기 등을 기다리는 상태

## 프로세스를 관리하는 구조
- PCB(Process control Block)을 사용하여 프로세스 관리
- 각 프로세스마다 한개 할당
- PCB가 가지는 대표적인 정보
```
CPU register : 현재 프로세스의 프로그램 카운터 값
PID : 현재 프로세스 식별ID
PPID : 부모 프로세스 아이디
중요도 : 스케줄링때 사용하는 중요성
프로세스 상태 : 앞에서 살펴본 3가지 상태
시그널 : 시그널핸들러 및 받은 시그널 신호들
CPU 스케줄링 정보 : 언제 실행되었는지, 중요도는 어떤지 등 스케줄링용 정보
MMAP : 메모리 맵
오픈 파일 정보
I/O상태
등등 매우 다양한 정보 사용
```
- 리눅스에서는 task_struct라는 자료구조를 사용

## Context Switch
- cpu 가상화는 여러번의 Context switch를 통해서 이루어진다. 
- 그래서 프로그래머는 레이스 컨디션등 특이한 상황을 제외하면 CPU를 전용한다고 생각하고 코드를 작성할 수 있다.
- 컨텍스트 전환은  크게 두가지 단계를 거침
1. 기존 프로세스의 정보들을 저장
2. 새 프로세스의 저장된 정보들을 불러오기
- 이러한 작업들은 생각보다 오버헤드가 큰 작업들 : 적정선을 찾아야함
- 컨텍스트 전환은 하드웨어, 특히 CPU 아키텍쳐에 큰 영향을 받음 : 레지스터세트가 서로 다르기 때문

## Limited Direct Execution
- 가장초기의 time sharing 기반 CPU 스케줄링 기법 
- OS가 프로세스이 실행에 전혀 관여없음
- 프로세스가 CPU를 한번 점유하면 끝날때까지 사용
- 문제점
1. 사용자 프로그램이 해선느 안되는 일을 할 수도 있음(보안영역 접근, I/O접근)등
2. CPU나 메모리자원을 혼자서 독점
- 해결법 : 권한을 2개로 나누자
1. 유저모드 : 일반적으로 하드웨어, 시스템기능에대한 제한적 접근
2. 커널모드 : 운영체제의 영역으로 모든 기능을 사용할 수 있음
- 시스템 콜을 이용하여 유저모드에서 커널모드로 하드웨어 시스템에 조심스럽게 접근 요청
### 시스템 콜
- 시스템콜은 유저영역에서 I/O등 하드웨어 자원을 사용하기 위해서 커널에 요청하는 함수이다. 
- trap이라는 과정으로 요청이 시작
- 유저영역에서 프로그램의 동작을 멈추고 커널 영역으로 들어가서 요청을 처리한다.
- trap table이라는 인터럽트 처리코드를 담은 테이블을 이용하여 처리를 하고 유저모드로 돌아간다.
- 정말 다양한 시스템 콜 존재

### 여러 프로세스가 있을때
- 여러 프로세스가 존재하면 어떻게 CPU점유를 관리할 것인가?
1. 협조(Cooperative) : 프로그램이 적당히 돌다가 알아서 wait를 건다.
2. 강탈(Non-Cooperative) : OS가 강제로 컨트롤을 뺏어온다.

### Cooperative 접근
- 프로세스가 cpu 자발적으로 포기 
- os는 다음 프로세스 결정만 하면된다.
- 물론 비정상적인 상황에서는 os가 cpu뺏어옴
- 최근엔 거의 사용하지 않음(악용가능)

### Non-Cooperative 접근
- 기본적으로 타이머 사용
- 타이머가 일정주기별로 강제 인터럽트 발생
- 인터럽트가 발생하면 OS가 cpu 뺐음
- 그후 다음 프로세스 선택

## CPU 스케줄링
- 다음에 실행될 프로세스를 선택하는 코드이다.
- 언제 스케줄링을 하는가?
1. 프로세스가 running -> waiting(blocked) : I/O 요청 등
2. 프로세스가 running -> ready : 시간 다씀
3. 프로세스가 waiting -> ready : I/O 요청 종료
4. 프로세스가 종료되었을때
- 1,4는 프로세스가 자발적 반납
- 2,3은 OS가 뺏음

### 스케줄링 알고리즘 평가기준
- utilization(효율성) : cpu 얼마나 효율적으로 사용?
- throughput(처리율) : 단위시간당 처리 프로세스수
- turnaround time(반환 시간) : 큐에 들어온 순간부터 끝난 시간
fairness(공평하게)하는것과 퍼포먼스 사이의 조율 필요
- waiting time(대기 시간) : 큐에 들어와서 기다린 시간
- response time(반응 시간) : 첫요청 -> 첫 스케줄링 시간
- 좋은 알고리즘은
utilization,throughput 높고
turnaround time,waiting time,response time 낮은 알고리즘
- 평균보다 분산을 줄이는것이 좋을때도 있음

### FIFO
- 선입선출 알고리즘
- 먼저 들어온 프로세스 순서대로 처리
- 하지만 앞의 프로세스가 시간이 너무 오래걸리면 tt가 안좋아짐
- Non-preemptive

### Shortest Job First
- 빠른 작업을 먼저 수행
- 작업 속도를 안다고 가정
- 동시에 요청이 들어온다고 가정
- 하지만 여전히 긴 작업이 미리 진행중이라면 tt 저하
- Non-preemptive

### Shortest Time-to-Completion First
- Preemptive
- OS권한으로 CPU 뺐기
- 남은 작업시간 비교해서 짧은 작업 실행

### 작업시간 예측
- 작업시간을 어떻게 알까?
- 과거 history보고 예측
- 다음예측값 = a*실제걸린시간 + (1-a)이전예측시간
![image](https://user-images.githubusercontent.com/30014736/185825852-9f35a485-3a7b-412f-8c9c-0a356ab83551.png)
- a값에 따라 최근값을 더 반영할것인지 이전값을 더 반영할것인지

### Round Robin
- 이제 tt 말고 rt(응답시간)도 관심사항
- time slice로 잘라서 큐에 넣고 돌려가며 실행
- 시간주고 못끝내면 큐의 끝으로 보냄
- 타이머 인터럽트가 필수
- 공평하기는 하지만 tt는 안좋음
- time slice가 짧으면 문맥교환시간이 증가->cpu효율 감소
- time slice가 길면 문맥교환시간 감소->응답시간 감소
- 적당한 trade-off 적당히

### Incorporating I/O
- 모든 프로그램은 I/O사용
- I/O요청중 노는시간동안 다른 프로세스 실행가능
